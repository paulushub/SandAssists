<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Sandcastle.Iris</name>
  </assembly>
  <members>
    <member name="M:Iris.Highlighting.VimBasedScanning.SyntaxItem.PrepareForRuntime">
      <summary>
            I will go up to the six-fingered man and say: "Hello, my name is Inigo Montoya. You killed my father. Prepare to die!" 
            </summary>
    </member>
    <member name="T:Iris.Highlighting.IScanner">
      <summary>
            Defines the interface that a scanner (tokenizer) must implement to work with Iris
            </summary>
    </member>
    <member name="M:Iris.Highlighting.IScanner.Scan(System.IO.TextReader,Iris.Highlighting.ICodeFormatter)">
      <summary>
            Scans the input by reading from a <see cref="T:System.IO.TextReader" />. Used for inputs up to 2GB.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.IScanner.Scan(System.String,Iris.Highlighting.ICodeFormatter)">
      <summary>
            Scans the input by reading from a <see cref="T:System.String" /></summary>
    </member>
    <member name="P:Iris.Highlighting.IScanner.SyntaxId">
      <summary>
            The id for the <see cref="T:Iris.Highlighting.Syntax" /> highlighted by this scanner
            </summary>
    </member>
    <member name="T:Iris.Highlighting.ICodeFormatter">
      <summary>
            Defines the interface for Iris code formatters. They are normally driven by an <see cref="T:Iris.Highlighting.IScanner" />.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ICodeFormatter.ChangeHighlightMode(Iris.Highlighting.HighlightMode)">
      <summary>
            Changes the current <see cref="T:Iris.Highlighting.HighlightMode">mode</see> for text being written.
            </summary>
      <param name="mode">
      </param>
    </member>
    <member name="M:Iris.Highlighting.ICodeFormatter.Finish">
      <summary>
            Finish working on a chunk of text to be highlighted. You can reuse the <see cref="T:Iris.Highlighting.ICodeFormatter">formatter</see>.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ICodeFormatter.ReportError(System.String)">
      <summary>
            Provides a mechanism for the <see cref="T:Iris.Highlighting.ICodeFormatter">formatter</see> to output an error message in a format-specific way.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ICodeFormatter.Start(System.IO.TextWriter,Iris.Highlighting.Syntax)">
      <summary>
            Start working on new input.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ICodeFormatter.Start(System.Xml.XmlWriter,Iris.Highlighting.Syntax)">
      <summary>
            Start working on new input with output going to a <see cref="T:System.Xml.XmlWriter" />.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ICodeFormatter.WriteNewLine">
      <summary>
            Writes new line
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ICodeFormatter.WriteText(System.String,System.Int32,System.Int32)">
      <summary>
            Writes text to the output. Text will be highlighted according to the current <see cref="T:Iris.Highlighting.HighlightMode">mode</see>.
            </summary>
      <param name="buffer">Buffer containing text to be written</param>
      <param name="posFirst">First position in buffer to be written, inclusive.</param>
      <param name="posLast">Last position in buffer to be written, inclusive.</param>
    </member>
    <member name="P:Iris.Highlighting.ICodeFormatter.SuggestedFileExtension">
      <summary>
            Gets the suggested file extension in case the caller wants to save formatted output to a file.
            </summary>
      <value>The suggested file extension.</value>
    </member>
    <member name="T:Iris.Highlighting.XmlFormatter">
      <summary>
            Highlights text using XML tags to indicate the <see cref="T:Iris.Highlighting.HighlightMode">mode</see> for each fragment of text.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.XmlFormatter.m_xmlWriterSettings">
      <summary>
            Ready-made <see cref="T:System.Xml.XmlWriterSettings" /></summary>
    </member>
    <member name="F:Iris.Highlighting.XmlFormatter.m_writer">
      <summary>
        <see cref="T:System.Xml.XmlWriter" /> that will receive all of the output
            </summary>
    </member>
    <member name="F:Iris.Highlighting.XmlFormatter.m_hasStartedMode">
      <summary>
            Whether any <see cref="T:Iris.Highlighting.HighlightMode">modes</see> have been started in this formatter.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.XmlFormatter.m_mode">
      <summary>
            The current <see cref="T:Iris.Highlighting.HighlightMode" /> for the formatter
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.ChangeHighlightMode(Iris.Highlighting.HighlightMode)">
      <summary>
            Changes the current <see cref="T:Iris.Highlighting.HighlightMode">mode</see> for text being written.
            </summary>
      <param name="mode">
      </param>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.Finish">
      <summary>
            Finish working on a chunk of text to be highlighted. You can reuse the <see cref="T:Iris.Highlighting.ICodeFormatter">formatter</see>.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.ReportError(System.String)">
      <summary>
            Writes an error message as an XML comment
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.Start(System.IO.TextWriter,Iris.Highlighting.Syntax)">
      <summary>
            Start work on a chunk of text. Internally, an <see cref="T:System.Xml.XmlWriter" /> is created atop the <paramref name="writer" />.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.Start(System.Xml.XmlWriter,Iris.Highlighting.Syntax)">
      <summary>
            Start work on a chunk of text with output to a <see cref="T:System.Xml.XmlWriter" />.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.WriteNewLine">
      <summary>
            Writes new line
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.WriteText(System.String,System.Int32,System.Int32)">
      <summary>
            Writes text to the output. Text will be highlighted according to the current <see cref="T:Iris.Highlighting.HighlightMode">mode</see>.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.Start(Iris.Highlighting.Syntax)">
      <summary>
            Prepares for highlighting of the specified <see cref="T:Iris.Highlighting.Syntax" /></summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.WriteModeEnd">
      <summary>
            Called when a <see cref="T:Iris.Highlighting.HighlightMode">mode</see> ends.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XmlFormatter.WriteModeStart(Iris.Highlighting.HighlightMode)">
      <summary>
            Called when a <see cref="T:Iris.Highlighting.HighlightMode">mode</see> starts.
            </summary>
    </member>
    <member name="P:Iris.Highlighting.XmlFormatter.SuggestedFileExtension">
      <summary>
            Gets the suggested file extension in case the caller wants to save formatted output to a file.
            </summary>
      <value>The suggested file extension.</value>
    </member>
    <member name="T:Iris.Highlighting.SyntaxCatalog">
      <summary>
            Provides access to the catalog of all syntaxes currently available in Iris.
            </summary>
      <remarks>
        <para>The catalog is initially loaded with information from the <b>IrisCatalog.xml</b> file. At runtime, you can dynamically add syntaxes via
            <see cref="M:Iris.Highlighting.SyntaxCatalog.Add(Iris.Highlighting.Syntax)" />. Syntaxes can be retrieved by their id or by aliases. <b>ALL</b> ids and aliases must be unique
            among themselves. In fact, ids and aliases all live happily in the same <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</para>
        <para>The id actually identifies the file that contains the definition for the syntax. This file lives in the 
            <b>syntax/</b> subdirectory and has extension ".vim", because it comes from the <see href="http://www.vim.org">Vim</see>
            text editor. For example, the "cs" syntax is defined in  file <b>syntax/cs.vim</b>. But you can add as many aliases as
            you see fit via <see cref="M:Iris.Highlighting.SyntaxCatalog.AddAlias(System.String,System.String)" />. For example, you could add "csharp", "c sharp", "C#" to make it easier for users
            to specify the C# language in a blog engine using Iris. But remember, these aliases must not collide with any other
            ids or aliases. 
            </para>
      </remarks>
    </member>
    <member name="M:Iris.Highlighting.SyntaxCatalog.Add(Iris.Highlighting.Syntax)">
      <summary>
            Adds a new <see cref="T:Iris.Highlighting.Syntax" /> to the <see cref="T:Iris.Highlighting.SyntaxCatalog">syntax catalog.</see></summary>
      <param name="newSyntax">New <see cref="T:Iris.Highlighting.Syntax" /> to be added. Its <see cref="F:Iris.Highlighting.Syntax.Id" /> must be unique, not taken by any other id or alias.</param>
    </member>
    <member name="M:Iris.Highlighting.SyntaxCatalog.AddAlias(System.String,System.String)">
      <summary>
            Adds an alias to an existing <see cref="T:Iris.Highlighting.Syntax" />.
            </summary>
      <devdoc>
            SHOULD: Move this to <see cref="T:Iris.Highlighting.Syntax" /> as instance method, collaborate with catalog to make sure alias is available.
            </devdoc>
      <param name="newAlias">New alias (eg, "c sharp") that will then be valid for retrieving the syntax</param>
      <param name="existingSyntaxId">The currently existing syntax id (eg, "cs")</param>
    </member>
    <member name="M:Iris.Highlighting.SyntaxCatalog.GetSyntaxBy(System.String)">
      <summary>
            Retrieves a <see cref="T:Iris.Highlighting.Syntax" /> by its id, or throws an exception if not found.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.SyntaxCatalog.GetSyntaxesSortedById">
      <summary>
            Gets all of the currently loaded syntaxes, sorted by their ids
            </summary>
    </member>
    <member name="M:Iris.Highlighting.SyntaxCatalog.TryGetSyntaxBy(System.String,Iris.Highlighting.Syntax@)">
      <summary>
            Retrieves a <see cref="T:Iris.Highlighting.Syntax" /> by its id, or <see langword="null" /> if no syntax is found with that id.
            </summary>
    </member>
    <member name="T:Iris.Highlighting.XhtmlOptions">
      <summary>
            Provides options to control the <see cref="T:Iris.Highlighting.XhtmlFormatter" /> output.
            </summary>
      <remarks>
        <para>Please see <see cref="T:Iris.Highlighting.XhtmlFormatter" /> for more discussion on outputting XHTML.</para>
      </remarks>
    </member>
    <member name="F:Iris.Highlighting.XhtmlOptions.Defaults">
      <summary>
            Provides a default ready-made <see cref="T:Iris.Highlighting.XhtmlOptions" /> object.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.XhtmlOptions.DefaultsWithoutStyleElement">
      <summary>
            Provides an <see cref="T:Iris.Highlighting.XhtmlOptions" /> object with <see cref="P:Iris.Highlighting.XhtmlOptions.EmitStyleTag" /> set to false
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XhtmlOptions.#ctor">
      <summary>
            Instantiates a new <see cref="T:Iris.Highlighting.XhtmlOptions" />.
            </summary>
    </member>
    <member name="P:Iris.Highlighting.XhtmlOptions.EmitStyleTag">
      <summary>
            Whether to emit a &lt;style&gt; tag containing the CSS stylesheet used in highlighting
            </summary>
    </member>
    <member name="P:Iris.Highlighting.XhtmlOptions.EmitLineNumbers">
      <summary>
            Whether to emit line numbers along with the highlighted output
            </summary>
    </member>
    <member name="P:Iris.Highlighting.XhtmlOptions.MarkNthLineNumber">
      <summary>
            Whether to emit every nth line number with the 'nthLineNumber' CSS class
            </summary>
    </member>
    <member name="P:Iris.Highlighting.XhtmlOptions.NthLineNumber">
      <summary>
            Every nth number that must be emitted with the 'nthLineNumber' CSS class
            </summary>
    </member>
    <member name="P:Iris.Highlighting.XhtmlOptions.CssScheme">
      <summary>
            Specifies the <see cref="T:Iris.Highlighting.CssScheme">CSS scheme</see> for highlighting. Only matters if <see cref="P:Iris.Highlighting.XhtmlOptions.EmitStyleTag" /> is true.
            </summary>
    </member>
    <member name="P:Iris.Highlighting.XhtmlOptions.NewLineChars">
      <summary>
            Specifies characters to use for new line
            </summary>
    </member>
    <member name="M:Iris.Highlighting.VimScriptParsing.VimScriptParser.#ctor(System.IO.FileInfo,System.Boolean)">
      <devdoc>
            SHOULD: refactor. First off, we need to make these parsing rules static to speed things up. Secondly, this whole scanning needs to be fixed
            up as these regexes are a bloody hack. This should tie in with full Vim script support.
            </devdoc>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.SetOfSyntaxItems.PrepareForRuntime(Iris.Highlighting.VimBasedScanning.SetOfSyntaxItems,Iris.Highlighting.VimBasedScanning.SyntaxDefinition)">
      <summary>
            I will go up to the six-fingered man and say: "Hello, my name is Inigo Montoya. You killed my father. Prepare to die!" 
            </summary>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.SetOfSyntaxItems.BuildCommunalRegex">
      <summary>
            Builds a regex that captures the start patterns for all vim matches and region starts in this <see cref="T:Iris.Highlighting.VimBasedScanning.SetOfSyntaxItems" />.
            Some patterns are not included and must be run manually (eg, the ones with <see cref="P:Iris.Highlighting.VimBasedScanning.Pattern.LeadingContext">leading context</see>).
            </summary>
    </member>
    <member name="T:Iris.Highlighting.VimBasedScanning.Extensions">
      <summary>
            Sorry replacement for some C# 3.0-style methods.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Extensions.AddSorted``1(System.Collections.Generic.List{``0},``0)">
      <summary>
            Adds a new element to sorted list preserving the sort order.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Extensions.ContainsSorted``1(System.Collections.Generic.List{``0},``0)">
      <summary>
            Determines whether the given sorted list contains the given item
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sortedList">The sorted list.</param>
      <param name="item">The item.</param>
      <returns>
        <c>true</c> if the specified sorted list contains sorted; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Extensions.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns the elements in a collection after removing duplicates, like DISTINCT in SQL.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Extensions.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns the set difference between two collections
            </summary>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Extensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},Common.Helpers.VoidFunc{``0})">
      <summary>
            Performs the specified action on each element in a collection
            </summary>
    </member>
    <member name="T:Iris.Highlighting.XhtmlFormatter">
      <summary>
            Formats highlighted output into XHTML fragments.
            </summary>
      <remarks>
        <para>
          <see cref="T:Iris.Highlighting.XhtmlFormatter" /> outputs highlighted text in XHTML. Each bit of the output text
            	is enclosed in a span tag, which in turn has a class attribute declaring a CSS class that corresponds to the <see cref="T:Iris.Highlighting.HighlightMode" /> 
            	for the text. The actual
            	formatting is done completely via CSS. The XHTML produced for the output is fully compliant with W3C XHTML strict, 
            	XHTML transitional, and HTML 4 (but there's a caveat below).
            </para>
        <para>
            	You must decide how to deliver the CSS stylesheet required by the XHTML-formatted output. The <see cref="T:Iris.Highlighting.CssScheme" /> object can
            	help you here. For any given scheme (eg, irisDefault, irisDark), <see cref="T:Iris.Highlighting.CssScheme" /> knows how to produce the CSS required for highlighting a given
            	input. You have three main options:
            	<list type="number"><item>Save the CSS stylesheet to a file in your server, and include a &lt;link&gt; tag in your XHTML document to reference the file</item><item>Output the required CSS to a &lt;style&gt; tag in the &lt;head&gt; of your XHTML document</item><item>Output a &lt;style&gt; tag just before the highlighted output. <b>This violates the XHTML standard</b> because &lt;style&gt;
            		is supposed to be inside the document's &lt;head&gt;. Nevertheless it's a pragmatic approach often taken.</item></list></para>
        <para>
            	Since the <see cref="T:Iris.Highlighting.XhtmlFormatter" /> can't touch your document's &lt;head&gt;, the only thing it can do out-of-the-box is #3 above.
            	It does that by default, so in practice things "just work", but every time you do it a purist cries somewhere. You can turn off the
            	auto-emitted &lt;style&gt; tag by using an <see cref="T:Iris.Highlighting.XhtmlOptions" /> object with <see cref="P:Iris.Highlighting.XhtmlOptions.EmitStyleTag" /> set to 
            	<see langword="false" />. You can then serve the CSS as a file or use the <see cref="T:Iris.Highlighting.CssScheme" /> to emit the style within &lt;head&gt;.
            </para>
      </remarks>
    </member>
    <member name="F:Iris.Highlighting.XhtmlFormatter.m_options">
      <summary>
            The <see cref="T:Iris.Highlighting.XhtmlOptions" /> controlling the output for this <see cref="T:Iris.Highlighting.XhtmlFormatter" /></summary>
    </member>
    <member name="M:Iris.Highlighting.XhtmlFormatter.#ctor(Iris.Highlighting.XhtmlOptions)">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.XhtmlFormatter" /> class with the specified options.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XhtmlFormatter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.XhtmlFormatter" /> using default options.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XhtmlFormatter.Finish">
      <summary>
            Finishes formatting a chunk of code.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XhtmlFormatter.WriteNewLine">
      <summary>
            Writes the characters in <see cref="P:Iris.Highlighting.XhtmlOptions.NewLineChars" /> and increments the line count.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.XhtmlFormatter.Start(Iris.Highlighting.Syntax)">
      <summary>
            Prepares for highlighting of the specified <see cref="T:Iris.Highlighting.Syntax" /></summary>
    </member>
    <member name="M:Iris.Highlighting.XhtmlFormatter.EmitStyleTag(System.String)">
      <summary>
            Emits a &lt;style&gt; tag containing the CSS style sheet for the given syntax and the current <see cref="P:Iris.Highlighting.XhtmlOptions.CssScheme" />.
            </summary>
      <param name="syntaxId">
      </param>
    </member>
    <member name="M:Iris.Highlighting.XhtmlFormatter.WriteModeStart(Iris.Highlighting.HighlightMode)">
      <summary>
            Called when a <see cref="T:Iris.Highlighting.HighlightMode">mode</see> starts.
            </summary>
      <param name="mode">
      </param>
    </member>
    <member name="P:Iris.Highlighting.XhtmlFormatter.SuggestedFileExtension">
      <summary>
            Gets the suggested file extension in case the caller wants to save formatted output to a file.
            </summary>
      <value>The suggested file extension.</value>
    </member>
    <member name="T:Iris.Highlighting.FullPageFormatter">
      <summary>
            Outputs a fully W3C-compliant XHTML page containing highlighted text (including &lt;html&gt;, &lt;head&gt;, and friends).
            </summary>
      <remarks>
        <para>The produced output validates correctly as HTML 4.1 transitional, XHTML transitional, and XHTML strict. However, currently there's
            no way to choose anything other than HTML 4.1. If you care about this, let us know as it's a 10-minute job.</para>
      </remarks>
    </member>
    <member name="M:Iris.Highlighting.FullPageFormatter.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.FullPageFormatter" /> class.
            </summary>
      <param name="pageTitle">The page title. May be empty, but not null.</param>
    </member>
    <member name="M:Iris.Highlighting.FullPageFormatter.Start(System.IO.TextWriter,Iris.Highlighting.Syntax)">
      <summary>
            Start work on a chunk of text. Internally, an <see cref="T:System.Xml.XmlWriter" /> is created atop the <paramref name="writer" />.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.FullPageFormatter.Start(Iris.Highlighting.Syntax)">
      <summary>
            Prepares for highlighting of the specified <see cref="T:Iris.Highlighting.Syntax" /></summary>
    </member>
    <member name="T:Iris.Highlighting.VimBasedScanning.Scanner">
      <summary>
            Scans text using a scanning engine like the one found in the Vim text editor.
            </summary>
      <remarks>
        <para>The Vim newline behavior is fairly quirky when it comes to highlighting. We have the following behavior:</para>
        <list type="number">
          <item>Suppose you have a match for "foobar", and it matches as the last word in a line (right before the line end). The subsequent matching
            then only starts in the NEXT line - the LF or CRLF are _skipped_, even though they were NOT part of the match. Notice the match
            didn't even have a $ at the end - it was simply the word 'foobar'! So basically, when you get to CRLF, it gets skipped automatically,
            line is over. This applies to _NEW_ matches - the CRLF gets skipped when it comes to NEW matches.</item>
          <item>The behavior above also happens for a keyword (ie, when the keyword is the last word right before the CRLF)</item>
          <item>The exact same behavior happens if the match has a dollar at the end (for example, "foobar$")</item>
          <item>Same behavior happens for skip patterns in regions. If the skip pattern matches right before the end of a line,
            the CRLF is then skipped, regardless of whether there's a $ at the end of the skip pattern.</item>
          <item>The ONE situation where this is different is when it comes to 'excludenl'. For a match and for the END pattern of a region,
            and ONLY for those two types of patterns, the 'excludenl' can have an effect as to whether the patterns will extend a region
            that ends in "$" (newline). If excludenl is true then, that is the ONLY situation in which the CRLF doesn't get skipped.</item>
        </list>
      </remarks>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Scanner.AdvanceWhileTryingToEndRegion(System.Int32@)">
      <devdoc>
            This method is a little complicated because it handles 2 cases. The simple one is ending the topmost region when the top scope
            is a region. The complex case is trying to end KeepEnd regions, even if they are NOT topmost. 
            So, the simple case will fall through the ifs below and only check for the end of the
            the topmost region at the current reading position. The complex case will walk char by char checking for the end of any keepend regions
            not being extended by an 'extend' item.
            </devdoc>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Scanner.TryKeyword(System.Int32@)">
      <devdoc>
            SHOULD: This whole mess needs to be replaced with a mini-state machine for keywords, which is easy to build
            since keywords have no magic chars, only literal chars. Would be _much_ faster and would not instantiate
            any objects.
            </devdoc>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.Scope.TryClearStaleEnd">
      <devdoc>
            if we just popped and fell into a region that is NOT a keepend, we must clear its end if it has one set, because
            the end became 'stale' - it was overriden by some sort of match (the one we're popping from)
            </devdoc>
    </member>
    <member name="T:Iris.Highlighting.SyntaxLoader">
      <summary>
            Provides methods related to the loading of syntax definition scripts
            </summary>
    </member>
    <member name="F:Iris.Highlighting.SyntaxLoader.CatalogFileName">
      <summary>
            "IrisCatalog.xml"
            </summary>
    </member>
    <member name="M:Iris.Highlighting.SyntaxLoader.FileInfoFromSyntaxId(System.String)">
      <summary>
            Given a syntax id, returns the file that contains the syntax definition script corresponding to the syntax
            </summary>
      <param name="syntaxId">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Iris.Highlighting.SyntaxLoader.SyntaxCatalogFile">
      <summary>
            The IrisCatalog.xml configuration file that contains the syntax and CSS Schemes catalog
            </summary>
    </member>
    <member name="P:Iris.Highlighting.SyntaxLoader.SyntaxDirectory">
      <summary>
            The directory that contains the syntax definition scripts
            </summary>
    </member>
    <member name="M:Iris.Highlighting.VimBasedScanning.PatternOffset.Apply(Iris.Highlighting.VimBasedScanning.MatchResult@,System.Int32,System.Int32)">
      <summary>
      </summary>
      <devdoc>
            Vim patterns are pretty quirky and inconsistent. See the file 'OffsetExperiments.vim' - it contains
            some experiments that show the behavior of offsets in Vim.
            </devdoc>
    </member>
    <member name="T:Iris.Highlighting.Highlighter">
      <summary>
             Highlights input according to a syntax definition. This is the central class in Iris.
             </summary>
      <remarks>
        <para>
          <see cref="T:Iris.Highlighting.Highlighter" /> is the class responsible for coordinating the transformation of textual input into highlighted output. It relies
            		on two main components, a <see cref="T:Iris.Highlighting.IScanner">scanner</see> and a <see cref="T:Iris.Highlighting.ICodeFormatter">formatter</see>. The <see cref="T:Iris.Highlighting.IScanner">scanner</see>
            		decides which <see cref="T:Iris.Highlighting.HighlightMode">mode</see> (eg, <see cref="F:Iris.Highlighting.HighlightMode.String" /> or <see cref="F:Iris.Highlighting.HighlightMode.Constant" />) should apply for 
            		each character in the input. The <see cref="T:Iris.Highlighting.ICodeFormatter">formatter</see> receives this information from the scanner and produces output in a certain
            		format (eg, <see cref="T:Iris.Highlighting.XmlFormatter" /> or <see cref="T:Iris.Highlighting.XhtmlFormatter" />). The highlighter itself does no work, it
            		simply relies on these two objects to get things done.
             </para>
        <para>
            		You can reuse Highlighters as many times as you wish. Creating highlighters is not expensive, but if you are highlighting often
            		you may want to cache your <see cref="T:Iris.Highlighting.Highlighter" />. Each individual instance is <b>not</b> thread safe. Here are some examples:
             </para>
        <example>
          <para>For quick and dirty highlighting, you can use the static <see cref="M:Iris.Highlighting.Highlighter.Highlight(System.String,System.String)" /> method. The downside
             is that you don't get to set any options.</para>
          <code>
            		string someCsharp = Highlighter.Highlight("cs", "public void Foo() {}");
            		string someC = Highlighter.Highlight("c", "printf(\"%s\", evilHackerInput)");
            		string someLua = Highlighter.Highlight("lua", "print \"Oi, mundo! Oi, PUC-RJ!\"");
             </code>
        </example>
        <example>
          <para>For better control over settings you may instantiate your own <see cref="T:Iris.Highlighting.Highlighter" />:</para>
          <code>
            		XhtmlFormatter formatter = new XhtmlFormatter(XhtmlOptions.Defaults);
            		Highlighter csHighlighter = new Highlighter("cs", formatter);
            		string prettyCSharp = csHighlighter.Highlight("public void Foozboo() {}");
            
            		// highlight a file
            		humoungousCSharpSource = File.OpenText("frozBlaster.cs");
            		outputFile = File.CreateText("frozBlaster.cs.html");
            		csHighlighter.Highlight(humongousCSharpSource, outputFile);
             </code>
        </example>
      </remarks>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.#ctor(System.String)">
      <summary>
            Instantiates a new <see cref="T:Iris.Highlighting.Highlighter" /> using the specified syntax id using a default <see cref="T:Iris.Highlighting.XhtmlFormatter" />.
            </summary>
      <param name="syntaxId">A syntax id that can be resolved via the <see cref="T:Iris.Highlighting.SyntaxCatalog" />.</param>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.#ctor(System.String,Iris.Highlighting.ICodeFormatter)">
      <summary>
            Instantiates a new <see cref="T:Iris.Highlighting.Highlighter" /> using the specified syntax id and formatter.
            </summary>
      <param name="syntaxIdOrAlias">A syntax id that can be resolved via the <see cref="T:Iris.Highlighting.SyntaxCatalog" />.</param>
      <param name="formatter">The <see cref="T:Iris.Highlighting.ICodeFormatter">formatter</see> to be used for output generation.</param>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.#ctor(Iris.Highlighting.Syntax,Iris.Highlighting.ICodeFormatter)">
      <summary>
            Instantiates a new <see cref="T:Iris.Highlighting.Highlighter" /> for the given <see cref="T:Iris.Highlighting.Syntax" /> using the specified formatter
            </summary>
      <param name="syntax">Any <see cref="T:Iris.Highlighting.Syntax" /> whose syntax definition file is present, regardless of whether it's in the <see cref="T:Iris.Highlighting.SyntaxCatalog" />.</param>
      <param name="formatter">The <see cref="T:Iris.Highlighting.ICodeFormatter">formatter</see> to be used for the output generation.</param>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.Highlight(System.String,System.String)">
      <summary>
            A convenience method to highlight input without instantiating a <see cref="T:Iris.Highlighting.Highlighter" />.
            </summary>
      <param name="syntaxId">A syntax id that can be resolved via the <see cref="T:Iris.Highlighting.SyntaxCatalog" />.</param>
      <param name="inputText">Text to be highlighted</param>
      <returns>Highlighted output</returns>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.Highlight(System.String)">
      <summary>
            Takes a string input and returns a string containing the highlighted output.
            </summary>
      <param name="inputText">Text to be highlighted</param>
      <returns>Highlighted output</returns>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.Highlight(System.String,System.IO.TextWriter)">
      <summary>
            Highlights the given string input, writing the output to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="inputText">Text to be highlighted</param>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> to receive output</param>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.Highlight(System.IO.TextReader,System.IO.TextWriter)">
      <summary>
            Reads input from a <see cref="T:System.IO.TextReader" /> and writes highlighted text to a <see cref="T:System.IO.TextWriter" />. Supports files up to 2GB.
            </summary>
      <param name="input">
        <see cref="T:System.IO.TextReader" /> where input will be read from</param>
      <param name="output">Output will be written using this <see cref="T:System.IO.TextWriter" /></param>
    </member>
    <member name="M:Iris.Highlighting.Highlighter.Highlight(System.IO.TextReader,System.Xml.XmlWriter)">
      <summary>
            Reads input from a <see cref="T:System.IO.TextReader" /> and writes highlighted text to a <see cref="T:System.Xml.XmlWriter" />. Supports files up to 2GB.
            </summary>
      <param name="input">
        <see cref="T:System.IO.TextReader" /> where input will be read from</param>
      <param name="output">Output will be written using this <see cref="T:System.Xml.XmlWriter" /></param>
    </member>
    <member name="T:Iris.Highlighting.NullFormatter">
      <summary>
            A test <see cref="T:Iris.Highlighting.ICodeFormatter">code formatter</see> that discards all scanner input.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.NullFormatter.ChangeHighlightMode(Iris.Highlighting.HighlightMode)">
      <summary>
            Jinxters the frobnozzle.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.NullFormatter.Finish">
      <summary>
            Finish off the opponent, a double clap at the end of the battle means 'bring on the next challenger'
            </summary>
    </member>
    <member name="M:Iris.Highlighting.NullFormatter.ReportError(System.String)">
      <summary>
            I program my home computer, take myself into the future
            </summary>
    </member>
    <member name="M:Iris.Highlighting.NullFormatter.Start(System.IO.TextWriter,Iris.Highlighting.Syntax)">
      <summary>
            When he first started mic respect's what he was after (af-ter)
            </summary>
    </member>
    <member name="M:Iris.Highlighting.NullFormatter.Start(System.Xml.XmlWriter,Iris.Highlighting.Syntax)">
      <summary>
            And so he got inside his mind, day and night, and he'd write
            </summary>
    </member>
    <member name="M:Iris.Highlighting.NullFormatter.WriteNewLine">
      <summary>
            Constantly his art and craft he'd try to master (mas-ter)
            </summary>
    </member>
    <member name="M:Iris.Highlighting.NullFormatter.WriteText(System.String,System.Int32,System.Int32)">
      <summary>
            Gave his crew a reputation as the best crew (best crew)
            </summary>
    </member>
    <member name="P:Iris.Highlighting.NullFormatter.SuggestedFileExtension">
      <summary>
            Returns <see langword="null" />.
            </summary>
    </member>
    <member name="T:Iris.Highlighting.VimBasedScanning.Cluster">
      <summary>
            Implements a Vim cluster, which is a set that contains groups and other clusters.
            </summary>
      <remarks>
        <para>This class implements two types of clusters. The first type are the obvious ones that get defined with "syntax cluster", these
            are the <b>named</b> clusters. The second type are the implicit clusters that get defined by Contains=, ContainedIn=, and NextGroup=.
            These are <b>unnamed</b> clusters.</para>
        <para>Clusters are global. If a syntax definiton file includes other files, all the clusters exist in the same namespace.</para>
      </remarks>
    </member>
    <member name="T:Iris.Highlighting.CssScheme">
      <summary>
            Encapsulates CSS stylesheets used for highlighting
            </summary>
      <remarks>
        <para>
            	When Iris starts up, it loads a number of "css schemes" configured in file <b>IrisCatalog.xml</b>. These 'schemes' are 
            	similar to a color scheme, but they are specified directly as CSS and thus can use all of CSS' features like fonts,
            	text decorations, borders, and so on. These loaded schemes are then available to be used by the formatters like the 
            	<see cref="T:Iris.Highlighting.XhtmlFormatter" />.
            </para>
        <para>
            	Each CSS scheme is divided in two sections: a <b>global</b> section contains CSS that applies to all syntaxes, and a per-syntax 
            	section contains CSS rules that apply only to a particular syntax. When Iris writes its output, it will always write out the
            	CSS in the global section, but will only write out the syntax-specific CSS for syntaxes that are being highlighted.
            </para>
      </remarks>
    </member>
    <member name="F:Iris.Highlighting.CssScheme.LongCssClassNamesForModes">
      <summary>
            Contains long CSS class names for each <see cref="T:Iris.Highlighting.HighlightMode" />, in the same order as they appear in the enumeration.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.CssScheme.ShortCssClassNamesForModes">
      <summary>
            Contains short CSS class names for each <see cref="T:Iris.Highlighting.HighlightMode" />, in the same order as they appear in the enumeration.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.CssScheme.GetAvailableCssSchemes">
      <summary>
            Returns the <see cref="T:Iris.Highlighting.CssScheme" /> objects that were loaded from the Iris catalog
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Iris.Highlighting.CssScheme.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.CssScheme" /> class.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.CssScheme.GetCssStyleSheetFor(System.String,System.String)">
      <summary>
            Builds a CSS stylesheet for highlighting the given syntax
            </summary>
      <returns>A stylesheet that could go inside a style element or a stand-alone CSS file</returns>
    </member>
    <member name="M:Iris.Highlighting.CssScheme.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
    </member>
    <member name="P:Iris.Highlighting.CssScheme.DefaultCssScheme">
      <summary>
            The default CSS scheme, originally loaded from <b>IrisCatalog.xml</b>.
            </summary>
    </member>
    <member name="P:Iris.Highlighting.CssScheme.GlobalStyleSheet">
      <summary>
            Contains the CSS rules that apply to all highlighted output, regardless of syntax
            </summary>
    </member>
    <member name="P:Iris.Highlighting.CssScheme.Name">
      <summary>
            Name of this CSS Scheme
            </summary>
    </member>
    <member name="P:Iris.Highlighting.CssScheme.PerSyntaxStyleSheets">
      <summary>
            Contains the CSS rules that apply to specific syntaxes, keyed by syntax id.
            </summary>
    </member>
    <member name="T:Iris.Highlighting.ConfigurationException">
      <summary>
            Thrown when Iris detects a problem in its configuration, which is stored in the <b>IrisCatalog.xml</b> file.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ConfigurationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.ConfigurationException" /> class.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ConfigurationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.ConfigurationException" /> class.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ConfigurationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.ConfigurationException" /> class.
            </summary>
    </member>
    <member name="M:Iris.Highlighting.ConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Iris.Highlighting.ConfigurationException" /> class.
            </summary>
    </member>
    <member name="T:Iris.Highlighting.HighlightMode">
      <summary>
            Specifies how a fragment of text should be highlighted (eg, Comment, Type, Number, Normal)
            </summary>
      <remarks>
        <para>This class is fundamentally important in Iris. All of the <see href="http://www.vim.org">Vim</see> syntax scripts used by Iris assign
            a <see cref="T:Iris.Highlighting.HighlightMode" /> to each and every part of their input text. So all languages, from ABAP to Zsh, boil down to the same
            constituents, which are the members of the <see cref="T:Iris.Highlighting.HighlightMode" /> enumeration. Users can then control the appearance of each
            of the modes, which works well because the same color scheme can work for several (hundred) languages.</para>
      </remarks>
      <devdoc>
            IMPORTANT: It's assumed throughout the code base that this enum starts at 0 and steps by 1 for each possible value.
            </devdoc>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.IrisBug">
      <summary>
            No text should ever have this mode. This indicates a bug in Iris
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Unknown">
      <summary>
            Used rarely when a Vim script doesn't properly choose a mode for a group of syntax items
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Normal">
      <summary>
            Regular, 'plain' text that is not magic for a given syntax.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Comment">
      <summary>
            Comment
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Boolean">
      <summary>
            Booleans, often constants like 'true' and 'false'
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Character">
      <summary>
            Usually a one-character literal in a language, such as 'p'
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Constant">
      <summary>
            Constant
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Float">
      <summary>
            Floating point number
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Number">
      <summary>
            Number
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.String">
      <summary>
            String literal
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Identifier">
      <summary>
            In some languages, variable names get this mode
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Function">
      <summary>
            Function names and sometimes function definitions
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Conditional">
      <summary>
            Normally keywords such as 'if', 'else', etc.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Exception">
      <summary>
            Exception-related stuff.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Keyword">
      <summary>
            Keyword
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Label">
      <summary>
            Labels, for example in goto and switch statements
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Operator">
      <summary>
            Operators like + and - that you learned in elementary school
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Repeat">
      <summary>
            Loopy statements like while and for.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Statement">
      <summary>
            Statement
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Define">
      <summary>
            Used in various way, for example #DEFINEs in C
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Include">
      <summary>
            File inclusion, as #include in C
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Macro">
      <summary>
            Macro definition or usage
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.PreCondit">
      <summary>
            Normally a pre-processor condition
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.PreProc">
      <summary>
            Pre-processor directive
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.StorageClass">
      <summary>
            Varies with language, but for example 'static' in C-type languages
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Structure">
      <summary>
            Example: struct in C
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Type">
      <summary>
            Type of an identifier
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Typedef">
      <summary>
            Type definition
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Debug">
      <summary>
            Debugging-related text
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Delimiter">
      <summary>
            Delimiters. Sometimes [, ], quotes, and so on.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Special">
      <summary>
            My mom thinks I'm special
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.SpecialChar">
      <summary>
            Special character
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.SpecialComment">
      <summary>
            Special comments
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Tag">
      <summary>
            Tags
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Underlined">
      <summary>
            Stuff that is meant to be underlined
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Error">
      <summary>
            This usually flags a syntax error in the input that was detected by the syntax script.
            </summary>
    </member>
    <member name="F:Iris.Highlighting.HighlightMode.Todo">
      <summary>
            Todo notes in languages often get this mode
            </summary>
    </member>
    <member name="T:Iris.Highlighting.Syntax">
      <summary>
            Represents a syntax definition that can be used to highlight text (eg, C#, C, or Lisp).
            </summary>
      <devdoc>
            MAY: refactor this so that Syntax is responsible for coming up with a FileInfo for its definition file. Also,
            allow people to create a syntax providing a FileInfo for the definition.
            </devdoc>
    </member>
    <member name="F:Iris.Highlighting.Syntax.Description">
      <summary>
            Describes the <see cref="T:Iris.Highlighting.Syntax" /> in a friendly way (eg, "ABEL Hardware Description Language").
            </summary>
    </member>
    <member name="F:Iris.Highlighting.Syntax.Id">
      <summary>
            Uniquely identifies this <see cref="T:Iris.Highlighting.Syntax" /> in the <see cref="T:Iris.Highlighting.SyntaxCatalog" /></summary>
    </member>
    <member name="M:Iris.Highlighting.Syntax.#ctor(System.String,System.String)">
      <summary>
            Instantiates a new <see cref="T:Iris.Highlighting.Syntax" /> with the given id and description
            </summary>
      <param name="id">Unique id for the syntax (eg, cs for C#)</param>
      <param name="description">Description (eg, Microsoft C#)</param>
    </member>
    <member name="M:Iris.Highlighting.Syntax.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
    </member>
    <member name="M:Iris.Highlighting.Syntax.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Iris.Highlighting.Syntax.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Iris.Highlighting.Syntax.ActiveCssScheme">
      <summary>
            Returns either the syntax's own <see cref="T:Iris.Highlighting.CssScheme" />, if one was defined, or <see cref="P:Iris.Highlighting.CssScheme.DefaultCssScheme" /></summary>
    </member>
    <member name="P:Iris.Highlighting.Syntax.CssSchemeOrNull">
      <summary>
            Returns <see langword="null" /> if a <see cref="T:Iris.Highlighting.CssScheme" /> has not been set, otherwise returns the <see cref="T:Iris.Highlighting.CssScheme" />.
            </summary>
    </member>
    <member name="P:Iris.Highlighting.Syntax.PossibleHighlightModes">
      <summary>
            Returns the possible <see cref="T:Iris.Highlighting.HighlightMode">highlight modes</see> this <see cref="T:Iris.Highlighting.Syntax" /> can produce.
            </summary>
    </member>
  </members>
</doc>