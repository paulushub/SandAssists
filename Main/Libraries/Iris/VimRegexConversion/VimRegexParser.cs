// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2006
// (see accompanying GPPGcopyright.rtf)


using System;
using System.Collections.Generic;
using System.Text;
using gppg;
using Common.Helpers;

namespace Iris.VimRegexConversion
{
public enum Tokens {
	error=1,EOF=2,LITERAL=3,QUANTIFIER=4,STARTGROUP=5,ENDGROUP=6,ZEROWIDTH=7,AND=8,
	OR=9,STARTCOLLECTION=10,COLLECTIONORNEWLINE=11,ENDCOLLECTION=12,STARTOPTIONALMATCH=13,ENDOPTIONALMATCH=14,CARET=15,DOLLAR=16};
internal class VimRegexParser: ShiftReduceParser<RegexUnit, LexLocation>
{

#pragma warning disable 162
	public RegexUnit Root;
	public bool MatchesMagicDollar;
  protected override void Initialize()
  {
	this.errToken = (int)Tokens.error;
	this.eofToken = (int)Tokens.EOF;

	states=new State[47];
	AddState(0,new State(new int[]{3,13,5,14,10,20,11,26,13,31,1,35,15,42,16,37,8,43,9,45},new int[]{-1,1,-3,17,-4,18,-5,41,-6,10,-7,19,-8,30}));
	AddState(1,new State(new int[]{2,2,9,3}));
	AddState(2,new State(-1));
	AddState(3,new State(new int[]{3,13,5,14,10,20,11,26,13,31,1,35,15,42,16,37,8,43,2,-4,9,-4,6,-4},new int[]{-3,4,-4,18,-5,41,-6,10,-7,19,-8,30}));
	AddState(4,new State(new int[]{8,5,2,-3,9,-3,6,-3}));
	AddState(5,new State(new int[]{3,13,5,14,10,20,11,26,13,31,1,35,15,42,16,37},new int[]{-4,6,-5,41,-6,10,-7,19,-8,30}));
	AddState(6,new State(new int[]{15,8,3,13,5,14,10,20,11,26,13,31,1,35,16,37,8,-7,2,-7,9,-7,6,-7},new int[]{-5,7,-6,10,-7,19,-8,30}));
	AddState(7,new State(-10));
	AddState(8,new State(new int[]{4,9,15,-12,3,-12,5,-12,10,-12,11,-12,13,-12,1,-12,16,-12,8,-12,2,-12,9,-12,6,-12}));
	AddState(9,new State(-15));
	AddState(10,new State(new int[]{4,11,7,12,15,-14,3,-14,5,-14,10,-14,11,-14,13,-14,1,-14,16,-14,8,-14,2,-14,9,-14,6,-14}));
	AddState(11,new State(-13));
	AddState(12,new State(-24));
	AddState(13,new State(-20));
	AddState(14,new State(new int[]{3,13,5,14,10,20,11,26,13,31,1,35,15,42,16,37,8,43,9,45},new int[]{-1,15,-3,17,-4,18,-5,41,-6,10,-7,19,-8,30}));
	AddState(15,new State(new int[]{6,16,9,3}));
	AddState(16,new State(-21));
	AddState(17,new State(new int[]{8,5,2,-2,9,-2,6,-2}));
	AddState(18,new State(new int[]{15,8,3,13,5,14,10,20,11,26,13,31,1,35,16,37,8,-6,2,-6,9,-6,6,-6},new int[]{-5,7,-6,10,-7,19,-8,30}));
	AddState(19,new State(-22));
	AddState(20,new State(new int[]{12,24,3,25},new int[]{-9,21}));
	AddState(21,new State(new int[]{12,22,3,23}));
	AddState(22,new State(-25));
	AddState(23,new State(-30));
	AddState(24,new State(-27));
	AddState(25,new State(-29));
	AddState(26,new State(new int[]{12,29,3,25},new int[]{-9,27}));
	AddState(27,new State(new int[]{12,28,3,23}));
	AddState(28,new State(-26));
	AddState(29,new State(-28));
	AddState(30,new State(-23));
	AddState(31,new State(new int[]{3,13,5,14,10,20,11,26,13,31,1,35},new int[]{-10,32,-6,36,-7,19,-8,30}));
	AddState(32,new State(new int[]{14,33,3,13,5,14,10,20,11,26,13,31,1,35},new int[]{-6,34,-7,19,-8,30}));
	AddState(33,new State(-31));
	AddState(34,new State(new int[]{7,12,14,-33,3,-33,5,-33,10,-33,11,-33,13,-33,1,-33}));
	AddState(35,new State(-34));
	AddState(36,new State(new int[]{7,12,14,-32,3,-32,5,-32,10,-32,11,-32,13,-32,1,-32}));
	AddState(37,new State(new int[]{15,38,4,40,3,13,5,14,10,20,11,26,13,31,1,35,16,37,8,-19,2,-19,9,-19,6,-19},new int[]{-5,39,-6,10,-7,19,-8,30}));
	AddState(38,new State(new int[]{4,9,15,-16,3,-16,5,-16,10,-16,11,-16,13,-16,1,-16,16,-16,8,-16,2,-16,9,-16,6,-16}));
	AddState(39,new State(-17));
	AddState(40,new State(-18));
	AddState(41,new State(-9));
	AddState(42,new State(new int[]{4,9,15,-11,3,-11,5,-11,10,-11,11,-11,13,-11,1,-11,16,-11,8,-11,2,-11,9,-11,6,-11}));
	AddState(43,new State(new int[]{3,13,5,14,10,20,11,26,13,31,1,35,15,42,16,37,8,43},new int[]{-3,44,-4,18,-5,41,-6,10,-7,19,-8,30}));
	AddState(44,new State(new int[]{8,5,2,-8,9,-8,6,-8}));
	AddState(45,new State(new int[]{3,13,5,14,10,20,11,26,13,31,1,35,15,42,16,37,8,43,9,45},new int[]{-1,46,-3,17,-4,18,-5,41,-6,10,-7,19,-8,30}));
	AddState(46,new State(new int[]{9,3,2,-5,6,-5}));

	rules=new Rule[35];
	rules[1]=new Rule(-2, new int[]{-1,2});
	rules[2]=new Rule(-1, new int[]{-3});
	rules[3]=new Rule(-1, new int[]{-1,9,-3});
	rules[4]=new Rule(-1, new int[]{-1,9});
	rules[5]=new Rule(-1, new int[]{9,-1});
	rules[6]=new Rule(-3, new int[]{-4});
	rules[7]=new Rule(-3, new int[]{-3,8,-4});
	rules[8]=new Rule(-3, new int[]{8,-3});
	rules[9]=new Rule(-4, new int[]{-5});
	rules[10]=new Rule(-4, new int[]{-4,-5});
	rules[11]=new Rule(-4, new int[]{15});
	rules[12]=new Rule(-4, new int[]{-4,15});
	rules[13]=new Rule(-5, new int[]{-6,4});
	rules[14]=new Rule(-5, new int[]{-6});
	rules[15]=new Rule(-5, new int[]{15,4});
	rules[16]=new Rule(-5, new int[]{16,15});
	rules[17]=new Rule(-5, new int[]{16,-5});
	rules[18]=new Rule(-5, new int[]{16,4});
	rules[19]=new Rule(-5, new int[]{16});
	rules[20]=new Rule(-6, new int[]{3});
	rules[21]=new Rule(-6, new int[]{5,-1,6});
	rules[22]=new Rule(-6, new int[]{-7});
	rules[23]=new Rule(-6, new int[]{-8});
	rules[24]=new Rule(-6, new int[]{-6,7});
	rules[25]=new Rule(-7, new int[]{10,-9,12});
	rules[26]=new Rule(-7, new int[]{11,-9,12});
	rules[27]=new Rule(-7, new int[]{10,12});
	rules[28]=new Rule(-7, new int[]{11,12});
	rules[29]=new Rule(-9, new int[]{3});
	rules[30]=new Rule(-9, new int[]{-9,3});
	rules[31]=new Rule(-8, new int[]{13,-10,14});
	rules[32]=new Rule(-10, new int[]{-6});
	rules[33]=new Rule(-10, new int[]{-10,-6});
	rules[34]=new Rule(-6, new int[]{1});

	nonTerminals = new string[] {"", "pattern", "$accept", "branch", "concat", 
	  "piece", "atom", "collection", "optionalmatch", "collectioncontents", "optionalmatchcontents", 
	  };
  }

  protected override void DoAction(int action)
  {
	switch (action)
	{
	  case 2: // pattern -> branch 
{
				yyval.Value = value_stack.array[value_stack.top-1].Value;
				this.Root = yyval;
			}
		break;
	  case 3: // pattern -> pattern OR branch 
{
				yyval.Value = value_stack.array[value_stack.top-3].Value + "|" + value_stack.array[value_stack.top-1].Value;
				this.Root = yyval;
			}
		break;
	  case 4: // pattern -> pattern OR 
{
				yyval.Value = value_stack.array[value_stack.top-2].Value + "|";
				this.Root = yyval;
			}
		break;
	  case 5: // pattern -> OR pattern 
{
				yyval.Value = "|" + value_stack.array[value_stack.top-1].Value;
				this.Root = yyval;
			}
		break;
	  case 7: // branch -> branch AND concat 
{ 
					value_stack.array[value_stack.top-3].AddConcat(value_stack.array[value_stack.top-1].Value); 
					yyval = value_stack.array[value_stack.top-3];
				}
		break;
	  case 8: // branch -> AND branch 
{
				yyval.Value = string.Empty;
				yyval.AddConcat(value_stack.array[value_stack.top-1].Value);
		}
		break;
	  case 10: // concat -> concat piece 
{ yyval.Value = value_stack.array[value_stack.top-2].Value + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 12: // concat -> concat CARET 
{ yyval.Value = value_stack.array[value_stack.top-2].Value + "\\^"; }
		break;
	  case 13: // piece -> atom QUANTIFIER 
{ yyval.Value = value_stack.array[value_stack.top-2].Value + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 15: // piece -> CARET QUANTIFIER 
{ yyval.Value = "\\^" + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 16: // piece -> DOLLAR CARET 
{ yyval.Value = "\\$\\^"; }
		break;
	  case 17: // piece -> DOLLAR piece 
{ yyval.Value = "\\$" + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 18: // piece -> DOLLAR QUANTIFIER 
{ yyval.Value = "\\$" + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 19: // piece -> DOLLAR 
{ yyval.Value = value_stack.array[value_stack.top-1].Value; this.MatchesMagicDollar = true; }
		break;
	  case 21: // atom -> STARTGROUP pattern ENDGROUP 
{ yyval.Value = value_stack.array[value_stack.top-3].Value + value_stack.array[value_stack.top-2].Value + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 24: // atom -> atom ZEROWIDTH 
{ yyval.Value = value_stack.array[value_stack.top-1].Value + value_stack.array[value_stack.top-2].Value + ")"; }
		break;
	  case 25: // collection -> STARTCOLLECTION collectioncontents ENDCOLLECTION 
{ yyval.Value = value_stack.array[value_stack.top-3].Value + value_stack.array[value_stack.top-2].Value + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 26: // collection -> COLLECTIONORNEWLINE collectioncontents ENDCOLLECTION 
{ 
						yyval.Value = StringExtensions.Fi("({0}|{1}{2}{3})", (this.scanner as VimRegexConverter).NewLine, value_stack.array[value_stack.top-3].Value, value_stack.array[value_stack.top-2].Value, value_stack.array[value_stack.top-1].Value); 
					}
		break;
	  case 27: // collection -> STARTCOLLECTION ENDCOLLECTION 
{ yyval.Value = value_stack.array[value_stack.top-2].Value + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 28: // collection -> COLLECTIONORNEWLINE ENDCOLLECTION 
{ yyval.Value = value_stack.array[value_stack.top-2].Value + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 30: // collectioncontents -> collectioncontents LITERAL 
{ yyval.Value = value_stack.array[value_stack.top-2].Value + value_stack.array[value_stack.top-1].Value; }
		break;
	  case 31: // optionalmatch -> STARTOPTIONALMATCH optionalmatchcontents ENDOPTIONALMATCH 
{ yyval.Value = value_stack.array[value_stack.top-2].BuildOptionalMatchContents(); }
		break;
	  case 33: // optionalmatchcontents -> optionalmatchcontents atom 
{ value_stack.array[value_stack.top-2].AddOptionalMatch(value_stack.array[value_stack.top-1].Value); yyval = value_stack.array[value_stack.top-2]; }
		break;
	  case 34: // atom -> error 
{ throw (new Exception("Parsing error")); }
		break;
	}
  }

  protected override string TerminalToString(int terminal)
  {
	if (((Tokens)terminal).ToString() != terminal.ToString())
	  return ((Tokens)terminal).ToString();
	else
	  return CharToString((char)terminal);
  }


}
}
